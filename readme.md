

[toc]

# Environment & Compilation

ubuntu 16.04/18.04

1. Download the toolchain ( [gcc-arm-bi-9-2019-q4-major-x86_64-linux.tar.bz2](https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2019q4/gcc-arm-bi-9-2019-q4-major-x86_64-linux.tar.bz2)) and extract to `~/toolchain/`

   ```
   mkdir -p ~/toolchain/
   tar -xvf gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2 -C ~/toolchain/
   ```

2. Add the toolchain in PATH in `~/.bashrc`

   ```bash
   export PATH=~/toolchain/gcc-arm-none-eabi-9-2019-q4-major/bin:$PATH
   ```

   And run `source ~/.bashrc` to make it work.

4. Compile

   ```bash
   tools/build.sh
   ```
   
   > output：`out/best2600w_aiot/best2600w_aiot.bin`



## tools

```bash
tools/
├─── burn/
|    ├─── dldtool.exe #cmd line burning tool for windows, never run it directly
|    ├─── dldtool32   #cmd line burning tool for 32bits linux, never run it directly
|    └─── dldtool64   #cmd line burning tool for 64bits linux, never run it directly
|    
├─── ota_bin/         #auto generated by dist.sh
|
├─── audiotool_v3.5.zip  #audio tool(WINDOWS), doc included
├─── build.sh   #shell to build
├─── burn.sh    #burning shell for linux.
├─── burn.bat   #burning shell for WIN
├─── dist.sh    #distribution tool
├─── genasm.sh  #objdump elf to asm. Usage: tools/genasm.sh [a|m]
├─── lzma       #compress tool, internal use
└─── mklittlefs #build the fs image, internal use
```



# Build & Dist & Burn

## Build

`tools/build.sh -a`     Building for boot1/boot2a/a7_dsp/m33

`tools/build.sh`           Building for a7_dsp/m33

`tools/build.sh -m`     Building for m33

Please run `tools/build.sh -h` for more information.



## Distribution

`tools/dist.sh` will run automatically after `tools/build.sh` for m33 successful build. Absolutely you can run it directly if all ready.

By default, 2 kinds of packages will be generated in `dist/`

```bash
dist_16m_flash_sec_20221108_065254.tar.gz               #cmd line package
write_flash_gui_16m_flash_sec_20221108_065252.tar.gz    #GUI package
```

Actually the command line package is from `tools/`, and the GUI package is from `tools/sign_write_tool/release/write_flash_gui/`

> You can update `tools/dist.sh` as follows to choose either kind of package generated.
>
> ```bash
> dist_gui_package
> dist_cmd_line_package 
> ```



### Signature

If built with `SECURE_BOOT=1`, `ota_boot1.bin/ota_boot2a.bin/ota_rtos.bin/programmer2003.bin` will signed with your private key. 

In `tools/sign_write_tool/release/auto_build_tool/bes_sign_tool/rsa3072_sign/rsa3072_key`

```bash
pri.pem      #private key
pub.pem      #public key
```



## Burn

### Preparation

EVB connected to PC and USB to serial driver installed.



### Linux

Run the following command in the root directory of your bes2600 project

```bash
tools/burn.sh all # burn: boot1/boot2/mcu firmware/fs.bin/factory.bin
tools/burn.sh  	  # burn mcu firmware
```

The burning tool is waiting for the device to restart to response. When the RESET or POWER button is pressed, it will burn.

First time, we have to burn all to build factory and file system. And for the following development, only the firmware needs to be burned if both `factory.bin` and `fs.bin` have no change.

### Window with Linux in VM

- Enable USB for VM

  Run `tools/burn.sh` as above

  

- Enable USB for Host

  Enable samba service in linux and share your bes2600 project. Map a local drive to `\\YourLinuxVM\share` in windows, like `X`. Open file explorer and navigate to `X:\<bes2600_proj>/tools`, Click to run `burn.bat` or `burn-all.bat` . 

  

  

# SECURITY BOOT

By default, `SECURE_BOOT` is set to 0, which means no security boot mechanism. You can set `SECURE_BOOT` to 1 in `consig/sdk.mk` or `tools/build.sh SECURE_BOOT=1`.

P.S. `SECURE_BOOT=1` just enable security boot mechanism, no signature verification at boot by default unless `AT+SECBOOT=SET,<sh256-hash-key>` is processed to take effect.

> Put your own RSA keys in:  `tools/sign_write_tool/release/auto_build_tool/bes_sign_tool/rsa3072_sign/rsa3072_key`

> **<u>`SECURE_BOOT=0` to `SECURE_BOOT=1` is irreversible</u>**, which means the firmware with `SECURE_BOOT=0` can't work again.

## Enable security boot

```bash
AT+SECBOOT=SET,c7b9f1b1570b1338a5d6e197140ce6d6a71ad6e2249136ed178a48d18f9fd69d
```

This will enable security boot with authentication as follows:

- Load the public key from NORFLASH OTP
- Calculate its signature with SH256
- Enable security boot if the signature is the same as provided in AT+SECBOOT
- Otherwise, authentication failed and illegal operation exits

The following booting log shows

```bash
#security boot disabled
security.reg:0, security.otp.security_en:0
#security boot enabled
security.reg:0x900b, security.otp.security_en:1
```

`security.otp.security_en` determines whether to check the signature to verify the integrity of boot1/boot2 a/boot2 b/rtos a/rtos b.  **<u>And it is irreversible.</u>**

> The hash key provided in `AT+SECBOOT` can be generated by `certutil` in WINDOWS
>
> ```bash
> certutil -hashfile ota_bin\pub_otp.bin SHA256
> ```



## Security boot process



```flow
bootROM=>start: BootROM
readEffuse=>operation: Read security.otp.security_en from efuse
condSecure=>condition: security_en?
sub1=>subroutine: Boot without verification
sub2=>subroutine: Boot with verification
bootROM->readEffuse->condSecure
condSecure(no)->sub1
condSecure(yes)->sub2
```



### Boot without verification

`security.otp.security_en=0`

```flow
st=>start: Boot without verification
boot1=>operation: Run boot1
bootinfo=>operation: Read bootinfo to choose boot2 a or b
boot2=>operation: Run boot2 a or b
bootinfo2=>operation: Read bootinfo to choose rtos a or b
rtos=>operation: Run rtos a or b
st->boot1->bootinfo->boot2->bootinfo2->rtos
```



### Boot with verification

`security.otp.security_en=1`

```flow
st=>start: Boot with verification
err=>operation: Exception
condBoot1=>condition: boot1 integrity?
condBoot2=>condition: boot2 a/b integrity?
condRTOS=>condition: rtos a/b integrity?
boot1=>operation: Run boot1
bootinfo=>operation: Read bootinfo to choose boot2 a or b
boot2=>operation: Run boot2 a or b
bootinfo2=>operation: Read bootinfo to choose rtos a or b
rtos=>operation: Run rtos a or b
st->condBoot1
condBoot1(no)->err
condBoot1(yes)->boot1->bootinfo->condBoot2
condBoot2(no)->err
condBoot2(yes)->boot2->bootinfo2->condRTOS
condRTOS(no)->err
condRTOS(yes)->rtos

```





# OTA

Please refer to `doc/SWIFT OTA Development Manual.pptx` for more details about OTA.

### OTA Demo

`apps/bes_test/libcurl/test_libcurl_client_http_ota.c`

- Config your ota server

  ```c
  #define HTTP_OTA_URL        "http://192.168.0.111/test/best2600w_aiot.bin"
  ```

- WIFI Connect to AP

  ```bash
  AT+WSCONN=ssid,passwd
  ```

- Start OTA

  ```bash
  AT+CUST=13
  ```

  If done,  "flash write bin finish!"  will be shown in the log and then reboot.



# AT commands

From now(2022-11-08) on, **bes2600wm** official release for AT module is included in `libservices.a` instead of source codes. For those AT commands we have updated, we move to `apps/besfd_api/console`

```bash
# The following AT overwritten
AT+MD
AT+WSCONN
AT+WSSETIP
AT+RECDUMP
AT+LPLAYER_START
AT+LPLAYER_STOP
AT+LPLAYER_PAUSE
AT+LPLAYER_VOL
AT+LPLAYER_SEEK
AT+LPLAYER_PLAY_TIME
# New AT
AT+BTMAC              # AT+SETBTMAC/AT+GETBTMAC obsolete
AT+BLEMAC             # AT+SETBLEMAC/AT+GETBLEMAC obsolete
AT+BTNAME             # AT+SETBTNAME obsolete
```



# File System

## FS Image For A7 DSP

For some special reasons who knows, DSP needs file system supported. But DSP can access the norflash, then RAMFS have to be used.

In `config/sdk.mk`: `MCU_SLAVE_FS_EN` and `PSRAMFS_SIZE` MUST be defined.

In `config/sdk-a7.mk`: `LITTLEFS_ENABLE` and `LFS_ON_RAM` MUST be enabled.

And copy all the preset files  to `fsdata/dsp/`

Thus, `out/best2600w_aiot/ramfs.bin` will be generated and linked to mcu.bin. It will be loaded to PSRAM at booting up.



## FS Image For MCU

For littlefs supported, the followings MUST be defined in `config/sdk-mcu.mk`:

```Makefile
export LITTLEFS_ENABLE=1
export LFS_ON_FLASH=1

ifeq ($(LITTLEFS_ENABLE)_$(LFS_ON_FLASH),1_1)
# ALWAYS enabled, NEVER changed
export LITTLEFS_PARTITION_SUPPORT=1

ifeq ($(FLASH_TYPE),0) #16M
#offset base on FLASH_NC_BASE
export LFS_FLASH_BASE_ADDR=0xd00000
#align(4k)
export LFS_FLASH_TOTAL_SIZE=0x200000
else #32M
#offset base on FLASH_NC_BASE
export LFS_FLASH_BASE_ADDR=0x1800000
#align(4k)
export LFS_FLASH_TOTAL_SIZE=0x500000
endif

KBUILD_CPPFLAGS += -DLITTLEFS_PARTITION_SUPPORT -DLFS_FLASH_TOTAL_SIZE=$(LFS_FLASH_TOTAL_SIZE) -DLFS_FLASH_BASE_ADDR=$(LFS_FLASH_BASE_ADDR)
endif
```

And copy all the preset files  to `fsdata/mcu/`

Thus, `out/best2600w_aiot/fs.bin` will be generated and it will be burned via `burn.sh or burn-all.bat`.



## API

### POSIX API for DIR 

In Makefile: `ccflags-y += -Iservices/wifi_app/littlefs/flash_partition`

`#include <sys/dirent.h>`

```c
DIR *opendir(const char *);
struct dirent *readdir(DIR *);
void rewinddir(DIR *);
int closedir(DIR *);
uint32_t telldir (DIR *);
void seekdir (DIR *, off_t loc);
```

### POSIX API for FILE

`include <stdio.h>`

```c
fopen/fclose/fseek/ftell/fread/fwrite/stat/access/remove/rename/mkdir/feof/fgetc/fgets
```



# Audio player

APIs in `services/lplayer_wrapper/aud_player.h`

```c
typedef int (*audplayer_complete_notify)(int errCode);
int aud_player_start(const char *urlOrFile, audplayer_complete_notify callback);
int aud_player_stop(void);
int aud_player_pause(void);
int aud_player_resume(void);
int aud_player_seek(uint32_t sec);
int aud_player_set_vol(int vol);
int aud_player_tell(void);
int aud_player_duration(void);
int aud_player_status(void);
```

> <u>**NOTICE: NEVER use APIs in `services/lplayer/interface/include/lplayer.h`**</u>



AT tests:

```bash
AT+LPLAYER_START=/cqdk.mp3		# play
AT_LPLAYER_PAUSE				# pause
AT+LPLAYER_START				# resume
AT+LPLAYER_STOP					# stop
AT+LPLAYER_SEEK=<pos>			# seek to the postion, unit: second
```



# BLE Demo

The datapath service shows how to communicate with the BES APP. It's very simple, just receive ssid&passwd and connect it.

Source codes: 

- datapath service: 

  `services/ble_proifles_v2/datapath/datapathps/`

  

- datapath app: 

  `services/ble_app_v2/app_datapath/`

  The APIs are in `app_datapath_server.h`

  

## BES App

|                   Android                   |                IOS                |
| :-----------------------------------------: | :-------------------------------: |
| ![android-bes-app](doc\android-bes-app.png) | Search "Bestechnic" in app store. |

> In BES app, some buttons are in Chinese. In the following steps, the corresponding translations are provided.

## How to configure wifi via BLE

1. BLE advertising

   The BLE advertising name is "ble_adv_test".

   ```bash
   AT+BTINIT=1
   AT+BLE=1,40
   ```

   

2. Register rx data callback for the datapath service

   ```bash
   AT+WIFICONFIG=0
   #app_datapath_server_register_rx_done(wifi_info_from_ble)
   ```

   

3. Using BES App to connect "ble_adv_test" and configure wifi ssid and passwd

   - TOOLS->Ble_Wifi->选择设备：choose "ble_adv_test"
   - 连接设备(Connect)

   - Fill in wifi ssid and password
   - 发送数据（Send）

   

4. Show ssid&passwd received and connect it

   ```bash
   AT+WIFICONFIG=1		# show ssid & passwd
   AT+WIFICONFIG=2		# connect
   ```

   

# gui&lvgl

`config/sdk-mcu.mk`

```makefile
export BFDGL=1
export LV_PROJ=demo
```

gui app is in `gui/demo` which is defined by `LV_PROJ`. You can port your own lvgl app here  and defined `LV_PROJ` to `your-own-lvgl-app`



# Wifi & BT test

Please refer to the doc

```bash
doc/BES2600WM_WiFi BT test flow-version2.6_20220112.pdf
```



