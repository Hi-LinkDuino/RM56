/* rsa.c
**
** Copyright 2012, The Android Open Source Project
**
** Redistribution and use in source and binary forms, with or without
** modification, are permitted provided that the following conditions are met:
**     * Redistributions of source code must retain the above copyright
**       notice, this list of conditions and the following disclaimer.
**     * Redistributions in binary form must reproduce the above copyright
**       notice, this list of conditions and the following disclaimer in the
**       documentation and/or other materials provided with the distribution.
**     * Neither the name of Google Inc. nor the names of its contributors may
**       be used to endorse or promote products derived from this software
**       without specific prior written permission.
**
** THIS SOFTWARE IS PROVIDED BY Google Inc. ``AS IS'' AND ANY EXPRESS OR
** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
** EVENT SHALL Google Inc. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
** PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
** OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
** OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
** ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <stddef.h>
#include <string.h>
#include "rsa.h"
#include "sha256.h"

#if SECURE_BOOT_VER >= 4
#ifndef RSA_PKCS1_PSS_PADDING
#define RSA_PKCS1_PSS_PADDING
#endif
#endif

// a[] -= mod
static void subM(const RSAPublicKey* key,
                 uint32_t* a) {
    int64_t A = 0;
    int i;
    for (i = 0; i < RSANUMWORDS; ++i) {
        A += (uint64_t)a[i] - key->n[i];
        a[i] = (uint32_t)A;
        A >>= 32;
    }
}

// return a[] >= mod
static int geM(const RSAPublicKey* key,
               const uint32_t* a) {
    int i;
    for (i = RSANUMWORDS; i;) {
        --i;
        if (a[i] < key->n[i]) return 0;
        if (a[i] > key->n[i]) return 1;
    }
    return 1;  // equal
}

// montgomery c[] += a * b[] / R % mod
static void montMulAdd(const RSAPublicKey* key,
                       uint32_t* c,
                       const uint32_t a,
                       const uint32_t* b) {
    uint64_t A = (uint64_t)a * b[0] + c[0];
    uint32_t d0 = (uint32_t)A * key->n0inv;
    uint64_t B = (uint64_t)d0 * key->n[0] + (uint32_t)A;
    int i;

    for (i = 1; i < RSANUMWORDS; ++i) {
        A = (A >> 32) + (uint64_t)a * b[i] + c[i];
        B = (B >> 32) + (uint64_t)d0 * key->n[i] + (uint32_t)A;
        c[i - 1] = (uint32_t)B;
    }

    A = (A >> 32) + (B >> 32);

    c[i - 1] = (uint32_t)A;

    if (A >> 32) {
        subM(key, c);
    }
}

// montgomery c[] = a[] * b[] / R % mod
static void montMul(const RSAPublicKey* key,
                    uint32_t* c,
                    const uint32_t* a,
                    const uint32_t* b) {
    int i;
    for (i = 0; i < RSANUMWORDS; ++i) {
        c[i] = 0;
    }
    for (i = 0; i < RSANUMWORDS; ++i) {
        montMulAdd(key, c, a[i], b);
    }
}

// In-place public exponentiation.
// Input and output big-endian byte array in inout.
static void modpow(const RSAPublicKey* key,
                   uint8_t* inout) {
    uint32_t a[RSANUMWORDS];
    uint32_t aR[RSANUMWORDS];
    uint32_t aaR[RSANUMWORDS];
    uint32_t* aaa = 0;
    int i;

    // Convert from big endian byte array to little endian word array.
    for (i = 0; i < RSANUMWORDS; ++i) {
        uint32_t tmp =
            (inout[((RSANUMWORDS - 1 - i) * 4) + 0] << 24) |
            (inout[((RSANUMWORDS - 1 - i) * 4) + 1] << 16) |
            (inout[((RSANUMWORDS - 1 - i) * 4) + 2] << 8) |
            (inout[((RSANUMWORDS - 1 - i) * 4) + 3] << 0);
        a[i] = tmp;
    }

#ifdef KEY_EXPONENT_65537
        aaa = aaR;  // Re-use location.
        montMul(key, aR, a, key->rr);  // aR = a * RR / R mod M
        for (i = 0; i < 16; i += 2) {
            montMul(key, aaR, aR, aR);  // aaR = aR * aR / R mod M
            montMul(key, aR, aaR, aaR);  // aR = aaR * aaR / R mod M
        }
        montMul(key, aaa, aR, a);  // aaa = aR * a / R mod M
#elif defined(KEY_EXPONENT_3)
        aaa = aR;  // Re-use location.
        montMul(key, aR, a, key->rr);  /* aR = a * RR / R mod M   */
        montMul(key, aaR, aR, aR);     /* aaR = aR * aR / R mod M */
        montMul(key, aaa, aaR, a);     /* aaa = aaR * a / R mod M */
#else
#error "No valid KEY_EXPONENT_XXX defined"
#endif

    // Make sure aaa < mod; aaa is at most 1x mod too large.
    if (geM(key, aaa)) {
        subM(key, aaa);
    }

    // Convert to bigendian byte array
    for (i = RSANUMWORDS - 1; i >= 0; --i) {
        uint32_t tmp = aaa[i];
        *inout++ = tmp >> 24;
        *inout++ = tmp >> 16;
        *inout++ = tmp >> 8;
        *inout++ = tmp >> 0;
    }
}

// Expected PKCS1.5 signature padding bytes, for a keytool RSA signature.
// Has the 0-length optional parameter encoded in the ASN1 (as opposed to the
// other flavor which omits the optional parameter entirely). This code does not
// accept signatures without the optional parameter.

/*
static const uint8_t sha256_padding[RSANUMBYTES] = {
    0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x30, 0x31, 0x30,
    0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65,
    0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20,

    // 32 bytes of hash go here.
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
};
*/

#ifdef RSA_PKCS1_PSS_PADDING
static const unsigned char zeroes[] = { 0, 0, 0, 0, 0, 0, 0, 0 };

static int BN_num_bits_word(uint32_t l)
{
    uint32_t i;
    for (i=31; i>=0; --i) {
        if (l & (1U<<i)) {
            return i+1;
        }
    }
    return 0;
}
static uint32_t BN_num_bits(const uint32_t *n)
{
    uint32_t i;
    for (i=RSANUMWORDS-1; i>=0; --i) {
        if (n[i]) {
            return i*8*sizeof(uint32_t) + BN_num_bits_word(n[i]);
        }
    }
    return 0;
}

static void PKCS1_MGF1(unsigned char *mask, uint32_t len,
               const unsigned char *seed, int32_t seedlen, int32_t mdlen)
{
    uint32_t i, outlen = 0;
    unsigned char cnt[4];
    SHA256_CTX ctx;
    unsigned char md[SHA256_DIGEST_SIZE];

    for (i = 0; outlen < len; i++) {
        cnt[0] = (unsigned char)((i >> 24) & 255);
        cnt[1] = (unsigned char)((i >> 16) & 255);
        cnt[2] = (unsigned char)((i >> 8)) & 255;
        cnt[3] = (unsigned char)(i & 255);

        SHA256_init(&ctx);
        SHA256_update(&ctx, seed, seedlen);
        SHA256_update(&ctx, cnt, 4);

        if (outlen + mdlen <= len) {
            memcpy(mask + outlen, SHA256_final(&ctx), SHA256_DIGEST_SIZE);
            outlen += mdlen;
        } else {
            memcpy(md, SHA256_final(&ctx), SHA256_DIGEST_SIZE);
            memcpy(mask + outlen, md, len - outlen);
            outlen = len;
        }
    }
}
static int RSA_verify_PKCS1_PSS_mgf1(const RSAPublicKey *key,
                                const uint8_t *mHash,
                                const int32_t hLen,
                                const uint8_t *EM,
                                int32_t emLen,
                                int sLen)
{
    int i;
    int ret = 0;
    int maskedDBLen, MSBits;
    const unsigned char *H;
    unsigned char DB[RSANUMBYTES-SHA256_DIGEST_SIZE] = {0};
    unsigned char H_[SHA256_DIGEST_SIZE] = {0};
    SHA256_CTX ctx;

    /*-
     * Negative sLen has special meanings:
     *      -1      sLen == hLen
     *      -2      salt length is autorecovered from signature
     *      -N      reserved
     */
    if (sLen == -1)
        sLen = hLen;
    else if (sLen == -2)
        sLen = -2;
    else if (sLen < -2) {
        ret = -1;
        goto err;
    }

    MSBits = (BN_num_bits(key->n) - 1) & 0x7;
    if (EM[0] & (0xFF << MSBits)) {
        ret = -2;
        goto err;
    }
    if (MSBits == 0) {
        EM++;
        emLen--;
    }
    if (emLen < hLen + 2) {
        ret = -3;
        goto err;
    }
    if (sLen > emLen - hLen - 2) { /* sLen can be small negative */
        ret = -4;
        goto err;
    }
    if (EM[emLen - 1] != 0xbc) {
        ret = -6;
        goto err;
    }
    maskedDBLen = emLen - hLen - 1;
    H = EM + maskedDBLen;
    PKCS1_MGF1(DB, maskedDBLen, H, hLen, SHA256_DIGEST_SIZE);

    for (i = 0; i < maskedDBLen; i++)
        DB[i] ^= EM[i];
    if (MSBits)
        DB[0] &= 0xFF >> (8 - MSBits);
    for (i = 0; i < (maskedDBLen - 1) && DB[i] == 0; i++) ;
    if (DB[i++] != 0x1) {
        ret = -7;
        goto err;
    }
    if (sLen >= 0 && (maskedDBLen - i) != sLen) {
        ret = -8;
        goto err;
    }
    SHA256_init(&ctx);
    SHA256_update(&ctx, zeroes, sizeof(zeroes));
    SHA256_update(&ctx, mHash, hLen);

    if (maskedDBLen - i) {
        SHA256_update(&ctx, DB + i, maskedDBLen - i);
    }

    memcpy(H_, SHA256_final(&ctx), SHA256_DIGEST_SIZE);

    if (memcmp(H_, H, hLen)) {
        ret = -9;
        goto err;
    }

    return 1;
 err:
    return ret;

}
#else /*RSA_PKCS1_PSS_PADDING*/
// SHA-256 of PKCS1.5 signature sha256_padding for 2048 bit, as above.
// At the location of the bytes of the hash all 00 are hashed.
#if RSANUMBYTES == 256
static const uint8_t kExpectedPadSha256Rsa2048[SHA256_DIGEST_SIZE] = {
    0xab, 0x28, 0x8d, 0x8a, 0xd7, 0xd9, 0x59, 0x92,
    0xba, 0xcc, 0xf8, 0x67, 0x20, 0xe1, 0x15, 0x2e,
    0x39, 0x8d, 0x80, 0x36, 0xd6, 0x6f, 0xf0, 0xfd,
    0x90, 0xe8, 0x7d, 0x8b, 0xe1, 0x7c, 0x87, 0x59,
};
#elif RSANUMBYTES == 384
static const uint8_t kExpectedPadSha256Rsa3072[SHA256_DIGEST_SIZE] = {
    0x54, 0xb2, 0x14, 0x21, 0x8a, 0xac, 0x4b, 0x6a,
    0x04, 0xfa, 0xee, 0x44, 0x33, 0xd1, 0x95, 0x4f,
    0xd8, 0x04, 0xc8, 0x11, 0xd7, 0xfb, 0x66, 0xad,
    0xf7, 0x38, 0xf7, 0x4d, 0xb8, 0xe8, 0x6f, 0x91,
};
#else
#error "invalid RSANUMBYTES"
#endif

#endif /*RSA_PKCS1_PSS_PADDING*/

// Verify a 2048-bit RSA PKCS1.5 or PKCS1 PSS signature against an expected hash.
//
// Returns 1 on successful verification, 0 on failure.
int RSA_verify_hash(int eng_en,
                    const RSAPublicKey *key,
                    const uint8_t *signature,
                    const uint32_t len,
                    const uint8_t *hash,
                    const uint32_t hash_len)
{
    uint8_t buf[RSANUMBYTES];
    unsigned int i;
#ifndef RSA_PKCS1_PSS_PADDING
    unsigned int j;
    const uint8_t* padding_hash;
#endif

    if (key == NULL || signature == NULL || hash == NULL) {
        return 0;
    }

    if (hash_len == 0) {
        return 0;
    }

    if (len != sizeof(buf)) {
        return 0;  // Wrong input length.
    }

    for (i = 0; i < len; ++i) {  // Copy input to local workspace.
        buf[i] = signature[i];
    }

    modpow(key, buf);  // In-place exponentiation.

#ifdef RSA_PKCS1_PSS_PADDING
    if (RSA_verify_PKCS1_PSS_mgf1(key, hash, hash_len, buf, RSANUMBYTES, -2) <= 0)
        return 0;
#else
    // Xor sha portion, so it all becomes 00 iff equal.
    for (i = len - hash_len, j = 0; i < len; ++i, ++j) {
        buf[i] ^= hash[j];
    }

    // Hash resulting buf, in-place.
    switch (hash_len) {
        case SHA256_DIGEST_SIZE:
#if RSANUMBYTES == 256
            padding_hash = kExpectedPadSha256Rsa2048;
#elif RSANUMBYTES == 384
            padding_hash = kExpectedPadSha256Rsa3072;
#else
#error "invalid RSANUMBYTES"
#endif
            hash_sha256(eng_en, buf, len, buf);
            break;
        default:
            return 0;
    }

    // Compare against expected hash value.
    for (i = 0; i < hash_len; ++i) {
        if (buf[i] != padding_hash[i]) {
            return 0;
        }
    }
#endif
    return 1;  // All checked out OK.
}

int RSA_verify(int eng_en,
               const RSAPublicKey *key,
               const uint8_t *signature,
               const uint32_t len,
               const uint8_t *msg,
               const uint32_t msg_len)
{
    unsigned char hash[SHA256_DIGEST_SIZE];
    unsigned int hash_len = sizeof(hash);

    if (key == NULL || signature == NULL || msg == NULL) {
        return 0;
    }

    if (msg_len == 0) {
        return 0;
    }

    hash_sha256(eng_en, msg, msg_len, hash);

    return RSA_verify_hash(eng_en, key, signature, len, hash, hash_len);
}

#define TEST_RSA

#ifdef TEST_RSA

// (1) To sign a file:
// openssl dgst -sha256 -sign pri.pem -out dgst.sig file
// (2) To verify a file:
// openssl dgst -sha256 -verify pub.pem -signature dgst.sig file

// (1) To sign a file with pss padding
// openssl sha256 -out message.sha256 -binary message.bin
// openssl pkeyutl -sign -in message.sha256 -inkey pri.pem  -out message.sign -pkeyopt digest:sha256 -pkeyopt rsa_padding_mode:pss -pkeyopt rsa_pss_saltlen:-2
// (2) To verify a file with pss padding
// openssl pkeyutl -verify -in message.sha256 -sigfile message.sign -pubin -inkey pub_3072.pem -pkeyopt digest:sha256 -pkeyopt rsa_padding_mode:pss -pkeyopt rsa_pss_saltlen:-2
static const unsigned char message[] = {
  0x33, 0x32, 0x35, 0x34, 0x33, 0x32, 0x35, 0x74,
  0x36, 0x77, 0x74, 0x67, 0x0a, 0x64, 0x73, 0x65,
  0x61, 0x6b, 0x67, 0x6a, 0x64, 0x73, 0x0a
};
static const uint32_t mlen = sizeof(message);

#if RSANUMBYTES == 256
//rsa 2048
static const unsigned char signature[] = {
    0xb8, 0x53, 0x1c, 0xd0, 0xbf, 0x12, 0x7c, 0x43, 0x6d, 0x6e, 0x8b, 0x95, 0xd3, 0x7c, 0x2f, 0x0c,
    0x0e, 0x5a, 0xe1, 0xab, 0x75, 0x49, 0xf0, 0xce, 0xa3, 0x70, 0x70, 0x3d, 0xf6, 0x9e, 0x68, 0x54,
    0xa3, 0x9d, 0x08, 0x73, 0xb1, 0x81, 0x06, 0xf3, 0x52, 0xf8, 0x29, 0x1e, 0xa4, 0x03, 0x35, 0xdb,
    0x0c, 0x5c, 0x6a, 0xdd, 0x65, 0x38, 0x0a, 0xea, 0x33, 0x47, 0x54, 0x12, 0xd0, 0xed, 0x53, 0xdd,
    0xad, 0xa2, 0xdb, 0x80, 0xd7, 0x70, 0xd0, 0xd4, 0xa1, 0x6d, 0x22, 0x6e, 0x60, 0x34, 0x6e, 0x4f,
    0xe9, 0xec, 0xb7, 0x71, 0xd1, 0x82, 0x2d, 0x08, 0x03, 0x46, 0x11, 0xa6, 0x3c, 0xed, 0x6f, 0x9f,
    0xef, 0x96, 0xe2, 0x70, 0x9a, 0x9e, 0x56, 0x2a, 0xd2, 0x26, 0x8f, 0x2f, 0xa5, 0x36, 0x82, 0xe0,
    0xf5, 0xff, 0x4e, 0x94, 0x5d, 0x03, 0x39, 0xf0, 0x75, 0x89, 0xac, 0x99, 0xc0, 0x7b, 0x89, 0xec,
    0x51, 0x75, 0x96, 0x4e, 0x24, 0x7a, 0x49, 0xa4, 0x34, 0xa0, 0x56, 0x29, 0xf9, 0x9a, 0x0c, 0x19,
    0xb0, 0xcf, 0x48, 0x12, 0x89, 0x78, 0xc6, 0x46, 0x90, 0x82, 0xe7, 0xe3, 0x7a, 0xf0, 0xd2, 0xf4,
    0xd9, 0x46, 0x66, 0xfb, 0xeb, 0x15, 0x7b, 0x62, 0xc0, 0x9f, 0xbb, 0xd0, 0xd3, 0x11, 0x87, 0xe7,
    0x3b, 0xa5, 0xd8, 0x1f, 0xc2, 0x6e, 0x9d, 0xe8, 0x2c, 0xfc, 0x99, 0x6f, 0xce, 0xb7, 0x8d, 0x60,
    0x85, 0x74, 0x75, 0xad, 0x8f, 0x33, 0xa7, 0xa2, 0xe6, 0xe8, 0xad, 0x7a, 0x4d, 0x92, 0xe9, 0x28,
    0xe1, 0x66, 0x13, 0x12, 0x4e, 0xcc, 0xef, 0xe5, 0xee, 0x28, 0x00, 0x7b, 0x04, 0xcb, 0x9b, 0xf0,
    0x73, 0xc4, 0xa1, 0x3b, 0x4b, 0x4a, 0xd0, 0x89, 0x74, 0x61, 0x48, 0xd9, 0xf7, 0x5d, 0xbf, 0x8e,
    0xf5, 0x1b, 0x32, 0x9b, 0xe3, 0xe7, 0x8e, 0x95, 0x14, 0xe3, 0xb6, 0x68, 0x00, 0x77, 0xc5, 0xcc,
};
static const uint32_t slen = sizeof(signature);

static const RSAPublicKey test_key = {
    0x18217b03,
    {
        0x3c28b855, 0x9f500084, 0xafa9e133, 0x8e0cb997,
        0xd27be6c6, 0x03275453, 0x6f1cf697, 0x340dcaef,
        0xea89b322, 0x59493a0f, 0xd789d171, 0xc015e7db,
        0x6da136df, 0x255a6bf9, 0x0e2be037, 0x3df7271a,
        0x605732b9, 0x8b22a096, 0x7347a23d, 0xab9b710b,
        0x540364fc, 0x9cd529d8, 0x4fbc9532, 0x7112f73d,
        0xb63da0f3, 0x398005f5, 0x444d2be8, 0x0fe6d9b4,
        0xcf1f1d5e, 0xf4bb3b58, 0xdeb231f5, 0x1a3a1b1f,
        0x65303e99, 0x6d04f347, 0x8790a0f9, 0xbfeae4dc,
        0x688182ce, 0x19ef2563, 0x3425c764, 0x744c0e20,
        0x8c6753e2, 0x57ec29e7, 0xd47bedc0, 0x0b937e14,
        0x841c2224, 0x8ccb6ac2, 0x2f803bfe, 0x38fb4152,
        0x9664552b, 0x1f53a140, 0x70b98306, 0xd180c3cd,
        0xa4429506, 0xf5aa931e, 0x2c55db22, 0xad1c3552,
        0x62435a97, 0x280dc64e, 0x33cfd547, 0xfc786659,
        0x45d9d278, 0x70e581f8, 0xb74aed1a, 0xe7623585,
    },
    {
        0x3fc30791, 0x47761b9d, 0x80fcf93e, 0x869dcff4,
        0x28400ec8, 0xcde2536d, 0x1a0d9dd7, 0xeb772afb,
        0x70b646b8, 0x10af187d, 0x6c4c981d, 0x2ccd4f48,
        0xd6b824bb, 0x5e274522, 0xc2ab8d8b, 0x0951cbda,
        0x3b3cd28a, 0xdb720724, 0xa41a9606, 0x931f48bc,
        0x1c3f4657, 0x9fc22b5e, 0xd51beb4a, 0xd33b54dc,
        0x4ca52f99, 0x9ad38968, 0x1d195d0c, 0x961ae0df,
        0x4aeeca14, 0xa9264ba5, 0x6545623b, 0x5908b940,
        0x65f5be61, 0x9b444d4f, 0xdeb851bb, 0x33c0cd3a,
        0x148e04d3, 0xf925f652, 0xdf0332fa, 0xf54d300d,
        0x9c8379c6, 0xc89cbcb6, 0xcfd4f61e, 0xc284b915,
        0x2d266511, 0xe572260f, 0x1b4ad57c, 0xa658ca62,
        0xea70c7e2, 0xa484012f, 0x91da0cc6, 0x59b4c4bb,
        0xc244f60e, 0x48cb0c0a, 0x820291a2, 0x1b34b5c1,
        0x75532b06, 0xd6aceb93, 0x74437e61, 0x96f2e5db,
        0xce14f997, 0x72deee7f, 0xc9e12ad4, 0x773cbb24,
    },
};
#elif RSANUMBYTES == 384
//rsa3072
#ifdef RSA_PKCS1_PSS_PADDING
static const unsigned char signature[] = {
    0x43, 0x6f, 0xa2, 0x45, 0x45, 0xd2, 0x62, 0x3a, 0x04, 0x60, 0x33, 0x8d, 0xc7, 0x6b, 0x94, 0x54,
    0xf6, 0x9e, 0xc2, 0xa8, 0x8e, 0x19, 0xb9, 0x81, 0x60, 0xa8, 0x84, 0x1c, 0x28, 0xbd, 0x6c, 0x3b,
    0x61, 0x7c, 0x6f, 0x9e, 0x25, 0xbb, 0x0b, 0xfb, 0x5b, 0xa0, 0xe5, 0x53, 0xd7, 0x23, 0x06, 0x96,
    0x0e, 0x95, 0xf1, 0x4c, 0x0b, 0xd8, 0xb0, 0x6e, 0xcc, 0x42, 0xb3, 0x73, 0xdf, 0xbb, 0x60, 0x5d,
    0xd0, 0x5c, 0xc1, 0xcd, 0x35, 0xc1, 0x96, 0xf7, 0x69, 0x73, 0x85, 0x07, 0x9f, 0xcd, 0xd5, 0x40,
    0xa7, 0x75, 0xe3, 0x2c, 0xbc, 0x13, 0xee, 0x2a, 0xfd, 0xa4, 0xb0, 0x77, 0x23, 0x79, 0xf6, 0xd2,
    0xe4, 0x55, 0xb5, 0x4c, 0x9d, 0xfe, 0x78, 0x50, 0xfa, 0x91, 0x97, 0xca, 0x9f, 0x6a, 0x87, 0x7a,
    0xec, 0x7b, 0xce, 0x08, 0x5b, 0xbb, 0x8f, 0x71, 0x57, 0x8a, 0xa3, 0x55, 0xfd, 0xa5, 0x01, 0x48,
    0x08, 0x58, 0x67, 0xf6, 0x02, 0x3a, 0xde, 0x18, 0x95, 0x83, 0x89, 0x16, 0x4a, 0x86, 0xbe, 0x8a,
    0xd2, 0x8b, 0x1b, 0xba, 0x64, 0xbe, 0xa3, 0x1a, 0x65, 0x6b, 0xaa, 0xe6, 0xed, 0x00, 0xee, 0xd7,
    0x3b, 0x3e, 0x8a, 0x89, 0x56, 0x2f, 0x6a, 0xd1, 0xd3, 0x69, 0x60, 0xe1, 0x8c, 0xd9, 0x69, 0x58,
    0x12, 0xf3, 0x43, 0x2a, 0xa8, 0xe3, 0x0b, 0x79, 0xda, 0x7e, 0x69, 0xdc, 0x65, 0xbf, 0xf4, 0x8e,
    0x1a, 0xd5, 0x24, 0xf9, 0xa1, 0xb3, 0x3c, 0xd6, 0xcb, 0x85, 0x15, 0x2b, 0x50, 0x1b, 0x74, 0x1a,
    0x91, 0xd9, 0x67, 0x00, 0x69, 0xa5, 0x7a, 0x80, 0x36, 0xc6, 0xb3, 0xbb, 0xb5, 0x26, 0xa9, 0xfb,
    0x16, 0xcb, 0x94, 0xa9, 0x81, 0x75, 0x99, 0xf2, 0xdd, 0x5b, 0x05, 0x54, 0x5e, 0x03, 0xca, 0x70,
    0x36, 0xd0, 0x84, 0x9a, 0x62, 0xc5, 0xd1, 0x73, 0x8c, 0xcf, 0x31, 0x6f, 0x11, 0xe0, 0x48, 0x44,
    0x7e, 0xf5, 0x24, 0xbb, 0xbe, 0xc4, 0x5b, 0xa0, 0x54, 0x00, 0xb3, 0x1a, 0x5d, 0x9c, 0xd8, 0x4e,
    0xcf, 0x21, 0x6e, 0x31, 0x91, 0xfe, 0x71, 0xee, 0x65, 0x27, 0xbe, 0x6d, 0x77, 0x35, 0xcf, 0x2d,
    0xdc, 0xcd, 0x19, 0xa8, 0x69, 0xa3, 0x5c, 0x61, 0x42, 0x98, 0x7e, 0x4c, 0xe6, 0x96, 0x2d, 0xa9,
    0x2b, 0xc7, 0x53, 0xe1, 0xd9, 0x3e, 0xf2, 0x1a, 0xd2, 0x55, 0x7d, 0xe7, 0xc3, 0xad, 0x2b, 0x19,
    0xbf, 0xf0, 0x1d, 0x22, 0xfa, 0xeb, 0x3c, 0x91, 0xfa, 0x47, 0x7f, 0x5f, 0xc8, 0x71, 0xad, 0xc3,
    0x2d, 0x11, 0x8b, 0x06, 0xa4, 0x72, 0x75, 0xe5, 0xcb, 0x74, 0xac, 0x05, 0x9e, 0xe2, 0xf7, 0x62,
    0xac, 0x0d, 0x53, 0x9e, 0x11, 0xb2, 0x48, 0x5e, 0x27, 0x22, 0xd4, 0x84, 0xfb, 0xf6, 0xbe, 0x96,
    0x67, 0xac, 0x91, 0xb0, 0xb9, 0x8c, 0x3e, 0x11, 0xf0, 0xd6, 0xc9, 0x53, 0x1e, 0x7d, 0x7b, 0x18,
};
#else
static const unsigned char signature[] = {
    0x2d, 0x17, 0x07, 0x37, 0x9d, 0x9b, 0xeb, 0xe3, 0x3e, 0x5e, 0xae, 0x7f, 0x23, 0xb8, 0x01, 0x0e,
    0x55, 0xb1, 0x95, 0x0c, 0x7a, 0xaf, 0xc5, 0x44, 0xe7, 0xf8, 0x01, 0x13, 0xc6, 0xfd, 0x2e, 0xbc,
    0x1e, 0xa5, 0xfb, 0x0a, 0x84, 0x4b, 0x07, 0x2b, 0x92, 0xfe, 0x6f, 0x98, 0x76, 0x55, 0x65, 0x32,
    0x7e, 0xa6, 0xf4, 0x3a, 0xaa, 0xfd, 0x8e, 0x08, 0xf4, 0x49, 0x5c, 0x00, 0x0d, 0x63, 0x31, 0x72,
    0xc6, 0x0a, 0x8c, 0xe9, 0x73, 0xdc, 0x25, 0xd8, 0x46, 0xa6, 0x85, 0x53, 0xad, 0x62, 0x06, 0x4a,
    0xa4, 0x14, 0xbd, 0xdf, 0x3b, 0xc4, 0xc1, 0x21, 0x74, 0x45, 0x1d, 0xbe, 0xd8, 0x82, 0xe5, 0xa9,
    0xeb, 0x12, 0x83, 0xee, 0xe7, 0xba, 0x6c, 0x86, 0x15, 0x0d, 0x7a, 0xc0, 0x42, 0x03, 0x5d, 0xf0,
    0xaf, 0x08, 0x14, 0xb8, 0xfd, 0x38, 0xee, 0x15, 0xa2, 0x74, 0xb8, 0xfd, 0x01, 0xc1, 0xd5, 0x1e,
    0xe2, 0x9b, 0x40, 0x5f, 0x14, 0x3a, 0x09, 0xde, 0xa4, 0xc7, 0x03, 0xfa, 0x15, 0x7d, 0xa6, 0xfd,
    0xd2, 0xba, 0xb0, 0x95, 0xad, 0x2c, 0x0b, 0x17, 0x29, 0x87, 0x58, 0x3b, 0x08, 0xe6, 0x58, 0x71,
    0x3c, 0x5e, 0x3d, 0xc1, 0xc3, 0x14, 0x21, 0x3a, 0x8c, 0xc4, 0xb8, 0x6d, 0x10, 0xf0, 0xc4, 0x2b,
    0x47, 0x7f, 0x2a, 0x69, 0x26, 0x0f, 0x4d, 0xc5, 0x83, 0xa7, 0xdc, 0xcb, 0xc2, 0x60, 0x02, 0x2a,
    0xd1, 0x4c, 0x73, 0x49, 0x7e, 0xb3, 0x25, 0x84, 0xcb, 0x99, 0x6c, 0xf0, 0x8b, 0xd3, 0x73, 0x8d,
    0x02, 0x75, 0x8b, 0xf5, 0xee, 0xcd, 0xf5, 0xd7, 0x38, 0x03, 0x26, 0x32, 0xdf, 0xa0, 0x49, 0x7f,
    0x90, 0xb5, 0x40, 0xd0, 0x6c, 0x5a, 0x29, 0x8e, 0x27, 0x80, 0xd3, 0x69, 0x5f, 0x3c, 0x3c, 0x54,
    0x1c, 0x36, 0x54, 0x81, 0xdf, 0x7c, 0x9f, 0x55, 0x5a, 0xb3, 0x70, 0x85, 0xc1, 0xc5, 0x01, 0x07,
    0xa8, 0x03, 0xe9, 0x40, 0x84, 0x6e, 0xc6, 0x07, 0x5f, 0x57, 0x95, 0xee, 0x55, 0x53, 0x7d, 0x89,
    0x17, 0xd0, 0x74, 0x0c, 0x3a, 0x1f, 0x20, 0x20, 0xf8, 0x55, 0x74, 0xf3, 0xe5, 0xa7, 0x76, 0xbb,
    0xee, 0x75, 0x2e, 0xfb, 0x2c, 0xf6, 0x94, 0xfd, 0xdb, 0x27, 0xe7, 0xdc, 0xdb, 0x31, 0x95, 0xd8,
    0x9f, 0xaa, 0x00, 0xea, 0xc4, 0x4e, 0x64, 0xee, 0xa4, 0x1d, 0x17, 0x53, 0x61, 0x40, 0x1f, 0xbd,
    0x1d, 0xc5, 0x96, 0xf3, 0x5f, 0xca, 0xad, 0x1c, 0xe9, 0xbe, 0xea, 0x06, 0x2b, 0x21, 0x0e, 0x00,
    0x3b, 0x6d, 0x28, 0x62, 0x2e, 0xa0, 0x73, 0x7f, 0xb1, 0x66, 0x17, 0x24, 0xae, 0xe9, 0xd9, 0xca,
    0xf6, 0xa0, 0x44, 0xc6, 0x7e, 0x1a, 0x92, 0x67, 0x76, 0xef, 0xce, 0x47, 0x2e, 0x33, 0xbc, 0x7f,
    0x86, 0x93, 0x9b, 0x01, 0x4a, 0xa0, 0x4f, 0xff, 0x21, 0xbf, 0xd5, 0x8c, 0x6d, 0xc1, 0x4d, 0x49,
};
#endif
static const uint32_t slen = sizeof(signature);

static const RSAPublicKey test_key = {
    0xba36b631,
    {
        0xf1211d2f, 0x4d443790, 0xf470f449, 0xd8fb9d51,
        0xb3e6c0aa, 0x066ce5be, 0x70587a4e, 0x4df946f0,
        0x030c06df, 0x7bb51243, 0xcebe5778, 0x798b6c0d,
        0x70b38eb9, 0x9ce544ce, 0xebc0a0fd, 0x5b907b8f,
        0x4902b526, 0x822905aa, 0xcb9d0198, 0xa572d8c2,
        0xfa01a6b4, 0x3063302c, 0x752de0ba, 0x6f269cd7,
        0x1b9ec597, 0x1ff64578, 0x79b993eb, 0x9d2ed087,
        0xacc557cc, 0xaa6bfe7e, 0x4d978f9b, 0x9409d47c,
        0x529e94a5, 0x2a4916ea, 0x776128f5, 0xffc2b6dc,
        0x92e99b1f, 0xcf638355, 0x0010b133, 0x51865ce4,
        0x33cd027b, 0xafd38fc5, 0x0c8cb507, 0x714a552c,
        0x75aa94e5, 0x1a1ed6bb, 0x438170ba, 0x100040f3,
        0x42c4abfc, 0x5ad3c6b3, 0x13b0abfc, 0xed414a57,
        0x90251c67, 0x6e52b420, 0xb577e4e7, 0x4b87a955,
        0xa814c252, 0x9db8adec, 0xb41f6beb, 0x8e286bff,
        0x7e894c76, 0xa38c8592, 0x4d7f2ada, 0x3f0df98a,
        0x92dd4c2c, 0x49036340, 0xc9b26042, 0xd500d034,
        0xbb8dbcf0, 0xa0572ddc, 0xd9212bba, 0x6a6b0ba1,
        0x6f19ad0a, 0x0bb5e103, 0xf457eb8d, 0x253d29dc,
        0x0d76dbab, 0x5b213e42, 0xe6768f95, 0x32cd42f7,
        0x57667a56, 0xe4a1770b, 0x3d16bf26, 0xa134cc0f,
        0x11c10853, 0x5706cada, 0x1ff3b492, 0x7ddd0907,
        0xa4e9be0f, 0x109ec23e, 0xcb6474a8, 0xe47b4c3c,
        0x2d7b66a6, 0xd128251f, 0xa08fdeb4, 0xf826c9e4,
    },
    {
        0xe34f2a16, 0xba909fcc, 0xd9b0c1f1, 0xf76784ca,
        0x21d3a84e, 0x69040315, 0x29a29a4e, 0x7f80c432,
        0x89847d8a, 0x762d37d1, 0x88e8c3d0, 0x3d10db27,
        0x82f05975, 0x0be1e36c, 0xa7f5d9b5, 0xb46cec67,
        0x3e25275c, 0xda5a3cfa, 0x1b53a284, 0x2afb3d57,
        0x2a55757c, 0xb35b94d1, 0x42467e9f, 0x8d694c90,
        0x5d210306, 0xd6372482, 0x5c6cdf66, 0x56971ec0,
        0xdb6483a5, 0xe3d2e6ad, 0x42069122, 0xdb302f31,
        0xcc3ee3b6, 0x16a5750c, 0x247d4655, 0x34803b0c,
        0x58c49514, 0x44f3e78f, 0x2c27400e, 0x05438259,
        0xd6c68ea3, 0xc9d9a01b, 0xb25073f7, 0xf63858ff,
        0x42dbcfee, 0x23cf4baa, 0x1d906fc6, 0x5a2473a7,
        0x97086c2e, 0x073611fa, 0x9299360a, 0xca6d8803,
        0xf788d506, 0x4a4c3f48, 0x5f8055e2, 0x825ff9fa,
        0x6b933aab, 0xa9bd0a89, 0x4cc84899, 0x1d3b0ec8,
        0xc45e7a2b, 0x8f5e5fd2, 0x8ea5098c, 0x3708768d,
        0x45443f5e, 0x41b067fd, 0x6500c063, 0x2baf376e,
        0x7313902d, 0xdee35a3f, 0x0b1383d8, 0x824ccb51,
        0xb69c3105, 0x80f667c3, 0x0184dbf7, 0x66e11bd7,
        0x51dfdf46, 0x28c6e533, 0xd58033f5, 0x24cb6fdd,
        0x03e7ed29, 0xafdc6d2b, 0x6e2e6652, 0xf5f367cb,
        0x37bea255, 0xd805c9ad, 0xc962886f, 0xa20ae564,
        0xf26c9c9b, 0xc64238d9, 0x290c726b, 0x75e3d83a,
        0xfcdfabc6, 0x4414d34e, 0xa0be8e5b, 0x4d51565d,
    },
};
#else
#error "invalid RSANUMBYTES"
#endif

#ifndef _WIN32
#include "hal_trace.h"
#include "hal_timer.h"

int test_rsa(void)
{
    int ret;
    uint32_t time;
    const RSAPublicKey *key = &test_key;

    time = hal_fast_sys_timer_get();

    ret = RSA_verify(0, key, signature, slen, message, mlen);
    if (ret != 1)
        TRACE(0, "RSA veriry fail");

    TRACE(0, "RSA verify done. msg_len:%d, time:%d us", mlen, FAST_TICKS_TO_US(hal_fast_sys_timer_get()-time));
    return ret;
}
#endif

#endif

